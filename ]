package request

import (
	"io"
	"fmt"
	"bytes"
)


type Request struct {
	RequestLine RequestLine
	state int
}

type RequestLine struct {
	HttpVersion   string
	RequestTarget string
	Method        string
}

func (r *Request) parse(data []byte) (int, error) {


}

func parseRequestLine(byts []byte) (*RequestLine, int, error) {

	var req RequestLine;
	var err error;
	var num_bytes int;
	var n int;
	
	idx := bytes.Index(byts, []byte("\r\n"));
	if (idx == -1) {

		err = fmt.Errorf("invalid packet %s\n", string(byts));
		return req, 0, nil
	}
	
	num_bytes = len(byts);
	byts = byts[:idx];
	tmps := string(byts);
	
	n, err = fmt.Sscanf(tmps, "%s %s HTTP/%s", &req.Method, &req.RequestTarget, &req.HttpVersion);
	if (n < 3) {

		err = fmt.Errorf("Failed to parse line\n");
	}


	if (req.Method != "GET" && req.Method != "POST" && req.Method != "PUT" && req.Method != "DELETE") {

		err = fmt.Errorf("Invalid method parsed\n");
	}

	if (req.HttpVersion != "1.1") {

		err = fmt.Errorf("Invalid version: %s %s %s\n", req.Method, req.RequestTarget, req.HttpVersion);
	}

	return req, num_bytes, err

}

func RequestFromReader(reader io.Reader) (*Request, error) {
	
	byts := make([]byte, 8);
	var reqs Request;
	buf := bufio.NewReader(reader);

	for (reqs.state == 0) {
		byts, err := buf.Read(byts);	
		if (err != nil) {

			fmt.Printf("Failed to read bytes from reader %z\n", err);
		}

		req, err := parseRequestLine(byts);

	}
	return &reqs, err

}
